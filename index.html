<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 03</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 03</h1>
</header>
<h1 id="chapter-03-using-the-copy-function">Chapter 03: Using the copy function</h1>
<p>The idea of the copy function is to copy a section of the canvas to another spot on it.</p>
<h2 id="creating-the-grid">Creating the grid</h2>
<p>To create the sections that will be copied, we first need a grid.</p>
<p>Define the number of rows and columns you want.</p>
<pre><code>    int columns = 20;
    int rows = 20;</code></pre>
<p>Then define the dimensions of the cells of the grid. This is done by dividing the canvas’s width by the number of columns and the canvas’s height by the number of rows.</p>
<pre><code>    int columnWidth = width / columns;
    int rowHeight = height / rows;</code></pre>
<h2 id="looping-through-the-cells">Looping through the cells</h2>
<p>Once the grid is set up, it’s time to go through it. This is done with a double for loop.</p>
<pre><code>    for (int y = 0; y &lt; rows; y++) {
        for (int x = 0; x &lt; columns; x++) {
            // Do something here...
        }
    }</code></pre>
<h2 id="copy">Copy</h2>
<figure>
<img src="circle_copy.png" title="Image" alt="A section of the circle copied to its right" /><figcaption aria-hidden="true">A section of the circle copied to its right</figcaption>
</figure>
<p>In the image above, a section of the circle is copied to the circle’s right.</p>
<p>The copy function works by duplicating a section of the canvas from a source to a destination.</p>
<p>The copy function has the parameters sx, sy, sw, sh, dx, dy, dw, dh.</p>
<p>sx and sy are the x- and y-coordinates of the top left corner of the area you want to copy. sw and sh define the width and height of the region to be copied.</p>
<p>dx, dy, dw, dh define the same parameters but for the destination of the area being copied.</p>
<p>The code snippet for creating the above image is:</p>
<pre><code>    circle(width / 2, height / 2, width / 2);

copy(int(width / 2), int(height / 2),
     int(width * 0.1), int(height * 0.1),
      int(width * 0.8), int(height * 0.5),
         int(width * 0.1), int(height * 0.1));</code></pre>
<h2 id="combining-loop-and-copy">Combining loop and copy</h2>
<p>In the loop we copy each cell in the grid to another location on the canvas. The trick for creating interesting patterns is to vary the destination of the copied sections.</p>
<p>Finding the sx and sy parameters is straightforward.</p>
<pre><code>    int sx = x * columnWidth;
    int sy = y * rowHeight;</code></pre>
<p>So is finding the source width and source height.</p>
<pre><code>    int sw = columnWidth;
    int sh = rowHeight;</code></pre>
<p>The destination section’s width and height are the same as the source’s width and height.</p>
<pre><code>    int dw = columnWidth;
    int dh = rowHeight;</code></pre>
<p>The magic happens in finding the destination’s x and y coordinates. We can change where the section is copied based on its source.</p>
<p>This is done by adding a shift to sx and sy. For this example I’ll vary the shift according to Processing’s Perlin noise function, using x and y as the function’s inputs.</p>
<pre><code>    int xShift = int(noise(x) * 100);
    int yShift = int(noise(y) * 100);</code></pre>
<h2 id="combining-loops-and-copy">Combining loops and copy</h2>
<figure>
<img src="circle_loop_copy.png" title="Image" alt="Loop and copy" /><figcaption aria-hidden="true">Loop and copy</figcaption>
</figure>
<p>Putting everything from this chapter together, the above image is the result of combining loops and the copy function.</p>
<pre><code>            void setup() {
                size(800, 800);
                background(255);
                stroke(0);
                fill(0);

                circle(width / 2, height / 2, width / 2);

                int columns = 20;
                int rows = 20;
                int columnWidth = width / columns;
                int rowHeight = height / rows;

                for (int y = 0; y &lt; rows; y++) {
                    for (int x = 0; x &lt; columns; x++) {
                        int sx = x * columnWidth;
                        int sy = y * rowHeight;
                        int sw = columnWidth;
                        int sh = rowHeight;
                        int dw = columnWidth;
                        int dh = rowHeight;
                        int xShift = int(noise(x) * 100);
                        int yShift = int(noise(y) * 100);
                        int dx = sx + xShift;
                        int dy = sy + yShift;
                        copy(sx, sy, sw, sh,
                             dx, dy, dw, dh);
                    }
                }
            }</code></pre>
</body>
</html>
